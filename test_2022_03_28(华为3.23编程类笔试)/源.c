#define _CRT_SECURE_NO_WARNINGS
#include<stdio.h>
//1、魔力台阶 100分
//科科最近在修炼魔法，一日他来到魔法城堡，城堡里有一个长长的台阶, 而台阶的最终点便是魔法奥秘。
//这是一个魔力台阶，每个台阶都有一个魔力值，魔力值代表下一步科科最大可以跨越的台阶数。科科当前处在第1级台阶上，但是科科的体力有限，最多只能跨越K次。科科现在拜托你帮他计算下他能否拿到魔法奥秘。
//如果能够拿到返回最少跨越的次数，拿不到则返回 - 1。
//
//解答要求
//时间限制 : C / C++ 1000ms, 其他语言 : 2000ms
//内存限制 : C / C++ 256MB, 其他语言 : 512MB
//
//输入
//台阶长度n(1 <= n <= 10 ^ 5)
//台阶魔力值，[M1, M2.....Mn]由一个长度为n的数组表示，代表1~n级台阶的魔力值。(0 <= Mi <= 10 ^ 5)
//最大的跨越次数K(1 <= k <= 10 ^ 5)
//
//输出
//输出一个整数，拿到魔法奥秘最少需要跨越的次数，如果拿不到，返回 - 1
int main()
{
	int n = 0;//台阶数
	int i = 0;
	int arr[100001] = { 0 };//魔力值
	int count = 0;//次数
	scanf("%d", &n);
	for (i = 1; i <= n; i++)
	{
		scanf("%d", &arr[i]);//每个台阶的魔力值
	}
	for (i = 1; i <= n; i += arr[i])
	{
		count++;
	}
	if (i >= n)
	{
		printf("%d", count);
	}
	else
		printf("-1");
	return 0;
}

//2 TLV匹配 200分
//描述 : 两端通过TLV格式的报文来通信，现在收到对端的一个TLV格式的消息包，要求生成匹配后的(tag, length, valueOffset)列表。具体要求如下 :
//	(1)消息包中多组tag、length、value紧密排列，其中tag.length各占1字节(uint8_t), value所占字节数等于length的值
//	(2)结果数组中tag值已知，需要填充每个tag对应数据的length和valueOffset值(valueOffset为value在原消息包中的起始偏移量（从0开始，以字节为单位))，即将消息包中的tag与结果数组中的tag进行匹配（可能存在匹配失败的情况，若结果数组中的tag在消息包中找不到，则length和valueOffset都为0)
//	(3)消息包和结果数组中的tag值都按升序排列，且不重复
//	(4)此消息包未被篡改，但尾部可能不完整，不完整的一组TLV请丢弃掉
//
//	解答要求
//	时间限制 : C / C++ 1000ms, 其他语言 : 2000ms内存限制 : C / C++ 32MB, 其他语言 : 64MB
//
//	输入
//	第一行 : 一个字符串，代表收到的消息包。字符串长度在10000以内。
//	说明1 : 字符串使用十六进制文本格式（字母为大写）来展示消息包的数据，如OF04ABABABAB代表一组TLV:前两个字符(0F）代表tag值为15，接下来两个字符（04）代表length值为4字节，接下来8个字符即为4字节的value。
//		说明2 : 输入字符串中，每一组TLV紧密排列，中间无空格等分隔符
//		第二行 : 需要匹配的tag数量n(0 < n < 1000) 。
//		后面n行 : 需要匹配的n个tag值（十进制表示)，递增排列
//
//	输出
//	和需要匹配的n个tag对应的n行匹配结果，每一行由长度和偏移量组成。
//
//	样例1
//
//	输入 :
//0F04ABABABAB
//1
//15
//
//输出 :
//	4 2
//
//	解释 :
//	tag15(十六进制0F)对应数据的长度为4，其value从第三个字节开始，因此偏移量为2
//
//	样例2
//
//	输入 :
//0F04ABABABAB1001FF
//2
//15
//17
//
//输出 :
//	4 2
//	0 0
//
//	解释：
//	第二个tag匹配失败




//3、安排面试官 300分
//有M个面试官，每个面试官熟悉的编程语言是一个列表，比如["Java", "C++", "Golang"]表示该面试官熟悉Java、C++和Golang三种语言。
//有N个面试者，按照面试者的机试选择的语言分配面试官进行面试。现在给定每个面试官最多面试x个人，每个面试者必须被不同的面试官面试2次，请问能否给出一个匹配使得所有的面试者都能被面试到。
//
//解答要求
//时间限制 : C / C++ 3000ms, 其他语言 : 6000ms内存限制 : C / C++ 256MB, 其他语言 : 512MB
//
//输入
//第一行输入3个整数，M, N, x。其中0 <= M <= 100，0 <= N <= 1000
//然后是M行，输入M个面试官熟悉的语言列表，多个语言之间以空格分割，语言字符串本身不存在空格
//然后是N行，输入N个面试者的机试所使用的语言。
//输出
//第一行输出字符串true或者false，表示能否匹配。
//如果能匹配，从第二行起输出一个二维数组match，如果第i个面试官面试第j个面试者，match[i][j] == 1，否则match[i][j] == 0。二维数组元素之间采用单个空格分割。如果有多种匹配，只需要输出其中一种正确的匹配即可
//
//样例1
//
//输入 :
//4 6 4
//Java C++ Python
//Python
//C++ Java
//Python
//Java
//Python
//C++
//Python
//C++
//Java
//
//输出 :
//true
//1 0 1 0 1 1
//0 1 0 1 0 0
//1 0 1 0 1 1
//0 1 0 1 0 0

int main()
{
	int m = 0;//面试官
	int n = 0;//面试者
	int x = 0;//一个面试官可面试x个面试者
	int i = 0;
	char strm[][100] = {0};
	char strn[][100] = {0};
	char data[100][100] = {0};
	int row = 0;
	int line = 0;
	for (i = 0; i < m; i++)
	{
		gets(strm);
		while ('\0' != strm[i])
		{
			if (' ' != strm[i])
			{
				data[line][row] = strm[i];
				row++;
				i++;
			}
			else
			{
				data[line][row] = '\0';
				row = 0;
				line++;
				i++;
			}
		}
		gets(strn);
	}
	
	return 0;
}

